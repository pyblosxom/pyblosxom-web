===================
Entry-level caching
===================

:Author: Will Guaraldi <will dot guaraldi at gmail dot com>
:Originally published: August 28, 2007
:URL: http://pyblosxom.sourceforge.net/2.0/plans/entrycache.html


History
=======

August 30, 2007 - Will Guaraldi

   * Updated the document based on conversation on pyblosxom-devel and
     posts from Asheesh, drear, and Ryan.

   * Added Changes section.

   * Added urls for archived discussion.

August 28, 2007 - Will Guaraldi

   * Wrote the initial document, emailed it to pyblosxom-devel.


Summary
=======

In previous versions of PyBlosxom, entry level caching was handled 
by the ``Pyblosxom.cache``  package particularly the ``entryshelve`` 
and ``entrypickle`` cache drivers.  The cache drivers tie into the 
entry system through the ``getFromCache`` and ``addToCache`` methods 
in ``Pyblosxom.entries.base``.

When there is no cache driver, ``getFromCache`` finds the ``cacheDriver``, 
calls ``get`` on it, that kicks up an exception, and then ``getFromCache`` 
returns ``None`` which causes entry objects to retrieve the information 
on their own.

As I see it, the problem with this architecture is three fold:

1. not having a cache driver enabled is more expensive than it should be
2. entry-level caching code is part of PyBlosxom core, but should be 
   done as plugins
3. you only get to use one cache driver


Proposed design
===============

Remove caching code from PyBlosxom codebase.

Add two entry-cache related callbacks:

* ``entrycache_get`` - 
  This retrieves items from the cache given an entryid.  Since this is a 
  callback, if one entry cache handling plugin can't handle the request, 
  it gets passed on to another.  This would allow for multiple levels of 
  caching.

* ``entrycache_update`` - 
  This updates items in the cache given an entryid.  Since this is a callback, 
  **all** entry cache handling plugins are notified of the update.


When entry data is required, we follow the following process to retrieve it:

1. Call ``entrycache_get`` passing in the entryid and the request.

   * If this returns an entry dict, we use that.

   * If this returns ``None``, we parse the entry.

2. Do stuff with the entry data....

3. Call ``entrycache_update`` passing in the entryid, request, and the entry dict.


Reimplement the two caching drivers as plugins that implement the ``entrycache_*``
callbacks.


Outstanding issues
==================

1. *If a user wants to use multiple entrycache plugins at the same time and the
   order in which these plugins execute is an issue, how does the user specify
   the order in which the plugins execute?*

   The user can use ``load_plugins`` which allows the user to specify which plugins
   are loaded and in which order.  The order the plugins are loaded corresponds to
   the order in which the plugins are executed during callbacks.

   If there's a situation where using ``load_plugins`` doesn't work, we can 
   work out an alternate solution then.


Discussion
==========

Discussion of this proposal is at:

gmane.org
   http://news.gmane.org/gmane.comp.web.pyblosxom.devel

sf.net
   http://sourceforge.net/mailarchive/forum.php?thread_name=185aeadc0708280759j16495b14o785eabef91920e25%40mail.gmail.com&forum_name=pyblosxom-devel
