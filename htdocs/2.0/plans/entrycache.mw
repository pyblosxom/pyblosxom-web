<div id="entry-level-caching" class="document">

= Entry-level caching =

{| class="docinfo" frame="void" rules="none" frame="void" rules="none"
! class="docinfo-name" | Author:
| Will Guaraldi &lt;will dot guaraldi at gmail dot com&gt;
|- class="field"
! class="docinfo-name" | Originally published:
| class="field-body" | August 28, 2007
|- class="field"
! class="docinfo-name" | URL:
| class="field-body" |
http://pyblosxom.sourceforge.net/2.0/plans/entrycache.html
|}

<div id="history" class="section">

= History =

August 30, 2007 - Will Guaraldi

<blockquote>

* Updated the document based on conversation on pyblosxom-devel and posts from Asheesh, drear, and Ryan.
* Added Changes section.
* Added urls for archived discussion.

 </blockquote>

August 28, 2007 - Will Guaraldi

<blockquote>

* Wrote the initial document, emailed it to pyblosxom-devel.

 </blockquote> </div><div id="summary" class="section">

= Summary =

In previous versions of PyBlosxom, entry level caching was handled by the <tt class="docutils literal"><span class="pre">Pyblosxom.cache</span></tt> package particularly the <tt class="docutils literal"><span class="pre">entryshelve</span></tt> and <tt class="docutils literal"><span class="pre">entrypickle</span></tt> cache drivers. The cache drivers tie into the entry system through the <tt class="docutils literal"><span class="pre">getFromCache</span></tt> and <tt class="docutils literal"><span class="pre">addToCache</span></tt> methods in <tt class="docutils literal"><span class="pre">Pyblosxom.entries.base</span></tt>.

When there is no cache driver, <tt class="docutils literal"><span class="pre">getFromCache</span></tt> finds the <tt class="docutils literal"><span class="pre">cacheDriver</span></tt>, calls <tt class="docutils literal"><span class="pre">get</span></tt> on it, that kicks up an exception, and then <tt class="docutils literal"><span class="pre">getFromCache</span></tt> returns <tt class="docutils literal"><span class="pre">None</span></tt> which causes entry objects to retrieve the information on their own.

As I see it, the problem with this architecture is three fold:

# not having a cache driver enabled is more expensive than it should be
# entry-level caching code is part of PyBlosxom core, but should be done as plugins
# you only get to use one cache driver

 </span><div id="proposed-design" class="section">

= Proposed design =

Remove caching code from PyBlosxom codebase.

Add two entry-cache related callbacks:

* <tt class="docutils literal"><span class="pre">entrycache_get</span></tt> - This retrieves items from the cache given an entryid. Since this is a callback, if one entry cache handling plugin can't handle the request, it gets passed on to another. This would allow for multiple levels of caching.
* <tt class="docutils literal"><span class="pre">entrycache_update</span></tt> - This updates items in the cache given an entryid. Since this is a callback, '''all''' entry cache handling plugins are notified of the update.

When entry data is required, we follow the following process to retrieve it:

# Call <tt class="docutils literal"><span class="pre">entrycache_get</span></tt> passing in the entryid and the request.
#* If this returns an entry dict, we use that.
#* If this returns <tt class="docutils literal"><span class="pre">None</span></tt>, we parse the entry.
# Do stuff with the entry data....
# Call <tt class="docutils literal"><span class="pre">entrycache_update</span></tt> passing in the entryid, request, and the entry dict.

Reimplement the two caching drivers as plugins that implement the <tt class="docutils literal"><span class="pre">entrycache_*</span></tt> callbacks.

 </span><div id="outstanding-issues" class="section">

= Outstanding issues =

# ''If a user wants to use multiple entrycache plugins at the same time and the order in which these plugins execute is an issue, how does the user specify the order in which the plugins execute?''
The user can use <tt class="docutils literal"><span class="pre">load_plugins</span></tt> which allows the user to specify which plugins are loaded and in which order. The order the plugins are loaded corresponds to the order in which the plugins are executed during callbacks.
If there's a situation where using <tt class="docutils literal"><span class="pre">load_plugins</span></tt> doesn't work, we can work out an alternate solution then.

 </span><div id="discussion" class="section">

= Discussion =

Discussion of this proposal is at:

; gmane.org
: http://news.gmane.org/gmane.comp.web.pyblosxom.devel
; sf.net
: [http://sourceforge.net/mailarchive/forum.php?thread_name=185aeadc0708280759j16495b14o785eabef91920e25%40mail.gmail.com&forum_name=pyblosxom-devel http://sourceforge.net/mailarchive/forum.php?thread_name=185aeadc0708280759j16495b14o785eabef91920e25%40mail.gmail.com&amp;forum_name=pyblosxom-devel]

 </div> </div><div class="footer">
----
[entrycache.txt View document source]. Generated on: 2007-10-31 18:17 UTC. Generated by [http://docutils.sourceforge.net/ Docutils] from [http://docutils.sourceforge.net/rst.html reStructuredText] source. </div>
