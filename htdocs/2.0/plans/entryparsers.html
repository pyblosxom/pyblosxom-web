<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Formatters and Entry parsers</title>
<meta name="author" content="Will Guaraldi &lt;will dot guaraldi at gmail dot com&gt;" />
<link rel="stylesheet" href="manual_style.css" type="text/css" />
</head>
<body>
<div class="document" id="formatters-and-entry-parsers">
<h1 class="title">Formatters and Entry parsers</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Will Guaraldi &lt;will dot guaraldi at gmail dot com&gt;</td></tr>
<tr class="field"><th class="docinfo-name">Originally published:</th><td class="field-body">September 29, 2007</td>
</tr>
<tr class="field"><th class="docinfo-name">URL:</th><td class="field-body"><a class="reference external" href="http://pyblosxom.sourceforge.net/2.0/plans/entryparsers.html">http://pyblosxom.sourceforge.net/2.0/plans/entryparsers.html</a></td>
</tr>
</tbody>
</table>
<div class="section" id="history">
<h1>History</h1>
<p>September 29, 2007 - Will Guaraldi</p>
<blockquote>
<ul class="simple">
<li>Wrote the initial document, posted it, emailed it to pyblosxom-devel
for discussion.</li>
</ul>
</blockquote>
</div>
<div class="section" id="summary">
<h1>Summary</h1>
<p>The current transformation chain for converting blog entry files into
stories has a few warts that need to be ironed out to allow for entries
from non-file sources, better handling of markup, and better handling
for preformat and postformat transforms.</p>
<p>This document briefly covers how entry files are transformed into HTML/XHTML
in pre-2.0 PyBlosxom, the problems incurred, and goes into detail about how
the transformation chain will work in PyBlosxom 2.0 and later versions.</p>
</div>
<div class="section" id="parsing-entries-in-pre-2-0">
<h1>Parsing entries in pre-2.0</h1>
<p>PyBlosxom prior to 2.0 allows people to write blog entries in a variety of
markup formats.  This is possible by the <tt class="docutils literal"><span class="pre">entryparser</span></tt> style of plugin.
Entryparser plugins have the following general structure (using the
restructured text entryparser as an example):</p>
<pre class="literal-block">
FILE_EXT = &quot;rst&quot;                                              [1]

def cb_entryparser(args):
  args[FILE_EXT] = readfile                                   [1]
  return args

def parse(story, request):
  ...

def readfile(filename, request):
  entryData = {}
  lines = open(filename).readlines()                          [2]

  if len(lines) == 0:
    return {&quot;title&quot;: &quot;&quot;, &quot;body&quot;: &quot;&quot;}

  title = lines.pop(0)                                        [3]

  # absorb meta data                                          [3]
  while lines and lines[0].startswith(&quot;#&quot;):
    meta = lines.pop(0)
    meta = meta[1:].strip()     # remove the hash
    meta = meta.split(&quot; &quot;, 1)
    entryData[meta[0]] = meta[1]

  body = parse(''.join(lines), request)
  entryData[&quot;title&quot;] = title
  entryData[&quot;body&quot;] = body

  # Call the postformat callbacks                             [3]
  tools.run_callback('postformat',
                     {'request': request,
                      'entry_data': entryData})
  return entryData
</pre>
<p>In <tt class="docutils literal"><span class="pre">[1]</span></tt>, we see the entryparser plugin binding the file extension
<tt class="docutils literal"><span class="pre">rst</span></tt> to the <tt class="docutils literal"><span class="pre">readfile</span></tt> function.  When the <tt class="docutils literal"><span class="pre">FileEntry</span></tt> class
is looking at an entry with the file extension <tt class="docutils literal"><span class="pre">rst</span></tt>, it calls
<tt class="docutils literal"><span class="pre">readfile</span></tt> to open the file, parse the contents, and fill in the
entry data.</p>
<p>In <tt class="docutils literal"><span class="pre">[2]</span></tt>, the entryparser plugin opens the file for reading and
reads in the lines.  Because of this, the entryparser plugin requires
a filename...  It won't work for non-files or file-like items.  Entries
that come from non-file sources cannot use entryparsers.</p>
<p>In the sections marked <tt class="docutils literal"><span class="pre">[3]</span></tt>, we see a bunch of code that's repeated
in all the other entryparsers:</p>
<ul class="simple">
<li>code to handle the structure of entry files</li>
<li>parsing of metadata lines</li>
<li>calling the <tt class="docutils literal"><span class="pre">postformat</span></tt> callback</li>
</ul>
<p>Then we have preformatters and postformatters, the semantics of
which aren't particularly clear.</p>
<p>The following specification codifies the semantics and behavior for
preformatters and postformatters and adds an additional callback for
formatting the body of an entry in a specified markup into HTML/XHTML.</p>
</div>
<div class="section" id="proposed-design-for-2-0">
<h1>Proposed design for 2.0</h1>
<div class="section" id="proposed-design">
<h2>Proposed design</h2>
<p>The <tt class="docutils literal"><span class="pre">blosxom_entry_parser</span></tt> takes a filename (string) or a file-like
object and a request object and does the following:</p>
<ol class="arabic">
<li><p class="first">open the file and read the lines into a <tt class="docutils literal"><span class="pre">StringIO</span></tt> and closes the file</p>
</li>
<li><p class="first">first line is the title -- this gets added to the metadata dict as <tt class="docutils literal"><span class="pre">title</span></tt></p>
</li>
<li><p class="first">parse metadata lines as metadata</p>
<p>Metadata lines are in the format <tt class="docutils literal"><span class="pre">#key</span> <span class="pre">value</span></tt>.  Examples:</p>
<pre class="literal-block">
#markup rst
#music I Like Puppies, Volume II
#mood happy
#comments no
</pre>
</li>
<li><p class="first">the remainder of the file is the body of the entry</p>
<ol class="arabic">
<li><p class="first">call the <tt class="docutils literal"><span class="pre">preformat</span></tt> callback</p>
<p>Arguments:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">request</span></tt> - this PyBlosxom request</li>
<li><tt class="docutils literal"><span class="pre">story</span></tt> - a file-like object (File, StringIO, ...)</li>
<li><tt class="docutils literal"><span class="pre">metadata</span></tt> - a dict of metadata associated with this entry
including the title</li>
</ul>
<p>Returns:</p>
<ul class="simple">
<li>the mutated story as a file-like object (File, StringIO, ...)
in the appropriate markup</li>
</ul>
<p>Example 1: a preformatter could expand Python code blocks in
a story executing the code blocks and replacing them with text.
Note: this could be problematic because the output has to be
in the markup that the story is in.</p>
<p>Example 2: a preformatter could fix common mispellings of &quot;PyBlosxom&quot;.</p>
<p>Note that the story data must be in a consistent markup.  If the
story is written in restructured text, then any changes to it
by preformatters must also be in restructured text.</p>
<p>Output of preformatters can be cached.</p>
<p><strong>Note:</strong> this marks a change in semantics and behavior of the preformat
callback.</p>
</li>
<li><p class="first">call the <tt class="docutils literal"><span class="pre">format</span></tt> callback</p>
<p>Arguments:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">request</span></tt> - the PyBlosxom request object</li>
<li><tt class="docutils literal"><span class="pre">story</span></tt> - a file-like object (File, StringIO, ...)</li>
<li><tt class="docutils literal"><span class="pre">metadata</span></tt> - a dict of metadata associated with this entry
including the title</li>
</ul>
<p>Returns:</p>
<ul class="simple">
<li>the mutated story as a file-like object (File, StringIO, ...)
as HTML/XHTML</li>
</ul>
<p>This callback does things that current entryparsers really want
to be doing: it converts the markup into the output format.</p>
<p>Once a formatter has parsed the story, the callback ends.</p>
<p>Formatters know whether this story is one they should to parse
by checking the metadata <tt class="docutils literal"><span class="pre">markup</span></tt>.  For example, the <tt class="docutils literal"><span class="pre">rst</span></tt>
formatter could check to see if <tt class="docutils literal"><span class="pre">markup</span></tt> was <tt class="docutils literal"><span class="pre">rst</span></tt>.</p>
<p>Example 1: a story is written in a loose wiki markup and the
formatter converts that loose wiki markup into HTML/XHTML and
expands wiki links:</p>
<pre class="literal-block">
My wiki page
#markup wiki
This is an example of a blog entry written using
[WikiMarkup].  It is *really* great!
</pre>
<p>Example 2: a story is written in restructured text markup and
the formatter converts that into HTML/XHTML using the docutils
library:</p>
<pre class="literal-block">
My reST page
#markup rst
*This* is an example of a blog entry written using
restructured text.  Restructured text is part of the
Docutils [1]_ project.

.. [1] http://docutils.sourceforge.net/
</pre>
<p>For story data that is already in HTML/XHTML, this is a no-op.</p>
<p>Output of formatters can be cached.</p>
</li>
<li><p class="first">call the <tt class="docutils literal"><span class="pre">postformat</span></tt> callback</p>
<p>Arguments:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">request</span></tt> - this PyBlosxom request</li>
<li><tt class="docutils literal"><span class="pre">story</span></tt> - a file-like object (File, StringIO, ...) in HTML/XHTML
format</li>
<li><tt class="docutils literal"><span class="pre">metadata</span></tt> - a dict of metadata associated with this entry including
the title</li>
</ul>
<p>Returns:</p>
<ul class="simple">
<li>the mutated story as a file-like object (File, StringIO, ...) in
HTML/XHTML format</li>
</ul>
<p>Example 1: the user got to this page after doing a Google search
and a postformatter highlights the search terms in the story text.</p>
<p>Example 2: a postformatter could add update/revision history
to the end of the story.</p>
<p>Output of postformatters should <strong>NOT</strong> be cached.  The <tt class="docutils literal"><span class="pre">postformat</span></tt>
callback should be called on all entries to be displayed even if
they come from a cache.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="a-note-about-entryparsers">
<h2>A note about entryparsers</h2>
<p>Entryparsers that are merely formatting story data should be changed to
implement the <tt class="docutils literal"><span class="pre">format</span></tt> callback.  This reduces the work they have
to do and allows them to operate on story data that's not in a file.</p>
<p>Future entryparsers should work on files that are not in the typical
entry format (title, metadata, body).  For example, writing an entry
parser is a good idea for handling entries that are in an mbox file.</p>
</div>
<div class="section" id="proposed-vocabulary">
<h2>Proposed vocabulary</h2>
<p>This gives us the following terms:</p>
<p>entryparser</p>
<blockquote>
<p>An entryparsers is a PyBlosxom plugin that handle file formats that are
not PyBlosxom entry files (title, metadata, body).</p>
<p>Example 1: An entryparser could parse entries that were emails in
a maildir.</p>
</blockquote>
<p>preformatter</p>
<blockquote>
<p>A preformatter is a PyBlosxom plugin that transforms the body of an
entry before the body of the entry has been converted from some markup
into HTML/XHTML.</p>
<p>Example 1: A preformatter could expand Python code blocks in the body
executing the code blocks and replacing them with text in the markup
the body is currently in.</p>
<p>Example 2: A preformatter could fix common mispellings of &quot;PyBlosxom&quot;.</p>
</blockquote>
<p>formatter</p>
<blockquote>
<p>A formatter is a PyBlosxom plugin that transforms the body of an
entry from some markup into HTML/XHTML.</p>
<p>Example 1: A formatter could convert a body from Restructured Text
into HTML/XHTML.</p>
<p>Example 2: A formatter could convert a body from markdown
into HTML/XHTML.</p>
</blockquote>
<p>postformatter</p>
<blockquote>
<p>A postformatter is a PyBlosxom plugin that transforms the body of
an entry after the body has been converted into HTML/XHTML.</p>
<p>Example 1: A postformatter could add update/revision history of the
entry to the end of the body.</p>
<p>Example 2: A postformatter could add HTML/XHTML to highlight words
from the Google search that brought the user to this page.</p>
</blockquote>
<p>Note that a single plugin can fill any of these rolls.  For example, there
can exist plugins that act as preformatters and postformatters.</p>
</div>
<div class="section" id="what-does-this-accomplish">
<h2>What does this accomplish</h2>
<p>This does the following for us:</p>
<ol class="arabic simple">
<li>It retains backwards compatability with pre-existing stuff.  All
current entryparsers will continue to work.</li>
<li>It allows the new system to handle any file-like object so we can
more easily handle data from non-file sources.  Plugins like
pystaticfile and wbgwiki will be able to support other markup.
Plugins that pull their entry data from a database will be able to
support other markup.</li>
<li>It allows plugins that format story data to focus on formatting
story data--they no longer need the boilerplate code they required
before for parsing out the title and metadata.  This fixes a
long-standing problem that not all entryparsers actually handled
metadata.</li>
<li>It allows all entries in a blog to have the same extension.  If you
use <tt class="docutils literal"><span class="pre">.txt</span></tt> then it's easier to deal with in terms of editors and
plain-text detection and such.  Your entry will be formatted based
on the <tt class="docutils literal"><span class="pre">markup</span></tt> metadata item.</li>
<li>This specification codifies the semantics and transformations of
preformatters, formatters, and postformatters and gives minor
examples of each.  It also codifies expectations of entry caching
plugins.</li>
</ol>
</div>
</div>
<div class="section" id="examples">
<h1>Examples</h1>
<p>These examples are pretty trivial and show off usage of the various
callbacks, but themselves don't really do much.</p>
<p>FIXME THey are all untested.</p>
<div class="section" id="example-of-preformatter">
<h2>Example of preformatter</h2>
<p>This is an example of a pre-formatter that expands an image macro
that looks like <tt class="docutils literal"><span class="pre">IMG(some_image.jpg)</span></tt> into a full <tt class="docutils literal"><span class="pre">&lt;img</span> <span class="pre">...&gt;</span></tt>
tag.</p>
<p>Code:</p>
<pre class="literal-block">
import re, StringIO

REGEX = re.compile(&quot;IMG\(([^\)])&quot;)

def cb_preformat(args):
   story = args[&quot;story&quot;].read()
   newstory = re.sub(&quot;&lt;img src=\&quot;\\g&lt;1&gt;\&quot;&gt;\\g&lt;1&gt;&lt;/a&gt;&quot;, story)

   return StringIO.StringIO(newstory)
</pre>
</div>
<div class="section" id="example-of-a-formatter">
<h2>Example of a formatter</h2>
<p>This is an example of a formatter that takes a story that's mostly
in HTML, but is missing &lt;p&gt; and &lt;br&gt; tags.  This adds &lt;br /&gt; and &lt;p&gt;
tags.</p>
<p>Code:</p>
<pre class="literal-block">
# Based on Wari's linebreaks preformatter.
import StringIO

def cb_format(args):
   metadata = args[&quot;metadata&quot;]
   story = args[&quot;story&quot;].read()

   if &quot;markup&quot; in metadata and metadata[&quot;markup&quot;] == &quot;linebreaks&quot;:
      newstory = re.sub(&quot;\n\n+&quot;, &quot;&lt;/p&gt;&lt;p&gt;&quot;, story)
      newstory = re.sub(&quot;\n&quot;, &quot;&lt;br /&gt;&quot;, newstory)
      story = StringIO.StringIO(&quot;&lt;p&gt;%s&lt;/p&gt;&quot; % newstory)

   return story
</pre>
</div>
<div class="section" id="example-of-a-postformatter">
<h2>Example of a postformatter</h2>
<p>This is an example of a postformatter that takes a story that is
in HTML and highlights terms if the user browsed to this page
after doing a Google search.</p>
<p>Code:</p>
<pre class="literal-block">
import re, urlparse, urllib, StringIO

# Based on Abe Fettig's highlightsearch preformatter.
def getGoogleSearch(url):
   # taken from Mark's log parser tool
   search = ''
   argstr = urlparse.urlparse(url)[4]
   if argstr:
      argv = [arg.find('=') &gt; -1 and arg.split('=', 1) or ('','')
              for arg in argstr.split('&amp;')]
      search = [value for key, value in argv if key == 'q']
      if not search:
         # google.yahoo.com uses p=... instead of q=...
         search = [value for key, value in argv if key == 'p']
      if search:
         search = search[0].lower()
   return search

def cb_postformat(args):
   req = args[&quot;request&quot;]
   # FIXME - this way of getting the http dict might go away
   http = req.getHttp()

   referer = http.get(&quot;referer&quot;, &quot;&quot;)

   story = args[&quot;story&quot;]

   searchwords = getGoogleSearch(referer)
   if searchwords:
      story = story.read()
      searchwords = urllib.unquote_plus(searchwords.lower())
      for word in searchwords.split():
         story = re.sub( word,
                         &quot;&lt;span style=\&quot;background-color: #ffcc00\&quot;&gt;\\g&lt;1&gt;&lt;/a&gt;&quot;,
                         story,
                         re.I )

      story = StringIO.StringIO(story)

   return story
</pre>
</div>
</div>
<div class="section" id="outstanding-issues">
<h1>Outstanding issues</h1>
<p>It might be an issue that we're calling <tt class="docutils literal"><span class="pre">read()</span></tt> and then re-wrapping into
a <tt class="docutils literal"><span class="pre">StringIO</span></tt>, but I think a file-like interface is the best one to use as
an intermediary.</p>
<p>There are no outstanding issues at this time.</p>
</div>
<div class="section" id="discussion">
<h1>Discussion</h1>
<p>Discussion of this proposal is at:</p>
<dl class="docutils">
<dt>gmane.org</dt>
<dd><a class="reference external" href="http://article.gmane.org/gmane.comp.web.pyblosxom.devel/1981">http://article.gmane.org/gmane.comp.web.pyblosxom.devel/1981</a></dd>
<dt>sf.net</dt>
<dd>FIXME</dd>
</dl>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="entryparsers.txt">View document source</a>.
Generated on: 2007-10-31 18:17 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
